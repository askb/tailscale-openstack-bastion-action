---
# SPDX-License-Identifier: Apache-2.0
# Test Tailscale Setup and Minimal Build

name: Test Tailscale Setup and Minimal Build

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      packer_template:
        description: "Packer template to build (e.g., builder.pkr.hcl)"
        required: false
        type: string
        default: "builder.pkr.hcl"
      packer_vars:
        description: "Packer vars file (e.g., ubuntu-22.04)"
        required: false
        type: string
        default: "ubuntu-22.04"
      bastion_flavor:
        description: "OpenStack instance flavor for bastion"
        required: false
        type: string
        default: "v3-standard-2"
      bastion_image:
        description: "Base image for bastion host"
        required: false
        type: string
        default: "Ubuntu 22.04.5 LTS (x86_64) [2025-03-27]"
      bastion_network:
        description: "Network for bastion host"
        required: false
        type: string
        default: "odlci"
      ssh_key_name:
        description: "SSH key name for bastion (optional, Tailscale SSH used by default)"
        required: false
        type: string
        default: ""
      debug_mode:
        description: "Enable debug logging"
        required: false
        type: boolean
        default: false
  push:
    branches: [main]
    paths:
      - "packer/**"
      - "common-packer/**"
  pull_request:
    branches: [main]
    paths:
      - "packer/**"
      - "common-packer/**"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PACKER_VERSION: "1.11.2"
  BASTION_NAME: "bastion-gh-${{ github.run_id }}"
  BASTION_WAIT_TIMEOUT: 300
  OPENSTACK_FLAVOR: ${{ inputs.bastion_flavor || 'v3-standard-4' }}
  OPENSTACK_IMAGE: ${{ inputs.bastion_image || 'Ubuntu 22.04.5 LTS (x86_64) [2025-03-27]' }}
  OPENSTACK_NETWORK: ${{ inputs.bastion_network || 'odlci' }}
  OPENSTACK_SSH_KEY: ${{ inputs.ssh_key_name || '' }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check.outputs.has-changes }}
      packer-path: ${{ steps.find-packer.outputs.packer-path }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Find packer directory
        id: find-packer
        run: |
          if [ -d "packer" ]; then
            echo "packer-path=packer" >> "$GITHUB_OUTPUT"
          elif [ -d "common-packer" ]; then
            echo "packer-path=common-packer" >> "$GITHUB_OUTPUT"
          elif [ -d "examples" ]; then
            echo "packer-path=examples" >> "$GITHUB_OUTPUT"
          else
            echo "packer-path=." >> "$GITHUB_OUTPUT"
          fi

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: check
        with:
          # For workflow_dispatch, compare against previous commit
          base: ${{ github.event.before || format('refs/heads/{0}', github.ref_name) }}
          filters: |
            has-changes:
              - 'packer/**'
              - 'common-packer/**'
              - 'examples/**'
              - 'vars/**'
              - 'templates/**'
              - 'provision/**'

  packer-build-openstack:
    needs: prepare
    runs-on: ubuntu-latest
    if: |
      needs.prepare.outputs.has-changes == 'true' ||
      github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true

      # ========================================
      # Step 1: Setup Tailscale VPN
      # ========================================
      - name: Setup Tailscale VPN
        uses: tailscale/github-action@6cae46e2d796f265265cfcf628b72a32b4d7cade # v3.3.0
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
          tags: tag:ci
          hostname: github-runner-${{ github.run_id }}
          args: --ssh --accept-routes --accept-dns=false

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Capture initial Tailscale status
        run: |
          echo "âœ… Tailscale status (initial):"
          sudo tailscale status || true
          sudo tailscale ip -4 | head -1 | sed 's/^/Runner TS IPv4: /'
          sudo tailscale ip -6 | head -1 | sed 's/^/Runner TS IPv6: /'
          mkdir -p logs
          sudo tailscale status --json | tee logs/tailscale-initial-status.json >/dev/null 2>&1 || true
          sudo tailscale status | tee logs/tailscale-initial-status.txt >/dev/null 2>&1 || true

      # ========================================
      # Step 2: Setup OpenStack CLI
      # ========================================
      - name: Setup Python and OpenStack CLI
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install OpenStack CLI
        run: |
          python -m pip install --upgrade pip
          pip install python-openstackclient
          pip freeze

      - name: Configure OpenStack credentials
        env:
          OS_AUTH_URL: ${{ secrets.OPENSTACK_AUTH_URL }}
          OS_PROJECT_ID: ${{ secrets.OPENSTACK_PROJECT_ID }}
          OS_PROJECT_NAME: ${{ secrets.OPENSTACK_PROJECT_NAME }}
          OS_USERNAME: ${{ secrets.OPENSTACK_USERNAME }}
          OS_PASSWORD_B64: ${{ secrets.OPENSTACK_PASSWORD_B64 }}
          OS_PASSWORD_PLAIN: ${{ secrets.OPENSTACK_PASSWORD }}
          OS_REGION_NAME: ${{ secrets.OPENSTACK_REGION }}
          OS_IDENTITY_API_VERSION: "3"
          OS_USER_DOMAIN_NAME: "Default"
          OS_PROJECT_DOMAIN_NAME: "Default"
        run: |
          # Decode password if base64 encoded version exists, otherwise use plain
          if [ -n "$OS_PASSWORD_B64" ]; then
            OS_PASSWORD=$(echo "$OS_PASSWORD_B64" | base64 --decode)
            echo "ðŸ” Using base64-decoded password"
          else
            OS_PASSWORD="$OS_PASSWORD_PLAIN"
            echo "âš ï¸  Using plain password (consider using OPENSTACK_PASSWORD_B64)"
          fi

          {
            echo "OS_AUTH_URL=${OS_AUTH_URL}"
            echo "OS_PROJECT_ID=${OS_PROJECT_ID}"
            echo "OS_PROJECT_NAME=${OS_PROJECT_NAME}"
            echo "OS_USERNAME=${OS_USERNAME}"
            echo "OS_PASSWORD=${OS_PASSWORD}"
            echo "OS_REGION_NAME=${OS_REGION_NAME}"
            echo "OS_IDENTITY_API_VERSION=${OS_IDENTITY_API_VERSION}"
            echo "OS_USER_DOMAIN_NAME=${OS_USER_DOMAIN_NAME}"
            echo "OS_PROJECT_DOMAIN_NAME=${OS_PROJECT_DOMAIN_NAME}"
          } >> "$GITHUB_ENV"

      - name: Test OpenStack connection
        run: |
          echo "Testing OpenStack connection..."
          openstack --version
          openstack server list --limit 1 || echo "No servers found or limited access"

      # ========================================
      # Step 3: Create and Launch Bastion Host
      # ========================================
      - name: Create cloud-init script for bastion
        run: |
          # Use enhanced cloud-init template with variable substitution
          export BASTION_HOSTNAME="${{ env.BASTION_NAME }}"
          export TAILSCALE_AUTH_KEY="${{ secrets.TAILSCALE_AUTH_KEY }}"

          # Create cloud-init from template or inline
          if [ -f "templates/bastion-cloud-init.yaml" ]; then
            echo "Using cloud-init template from repository..."
            envsubst "\${BASTION_HOSTNAME} \${TAILSCALE_AUTH_KEY}" < templates/bastion-cloud-init.yaml > cloud-init.yaml
          else
            echo "Creating inline cloud-init configuration..."
            cat > cloud-init.yaml <<'EOFCI'
          #cloud-config
          # OpenStack Tailscale Bastion Host Cloud-Init
          hostname: ${BASTION_HOSTNAME}
          manage_etc_hosts: true

          package_update: true
          package_upgrade: true

          packages:
            - curl
            - wget
            - jq
            - net-tools
            - iputils-ping
            - ca-certificates
            - python3
            - python3-pip

          write_files:
            - path: /etc/sysctl.d/99-tailscale.conf
              content: |
                net.ipv4.ip_forward = 1
                net.ipv6.conf.all.forwarding = 1
                net.netfilter.nf_conntrack_max = 131072
              permissions: '0644'

            - path: /usr/local/bin/bastion-init.sh
              content: |
                #!/bin/bash
                set -e
                echo "[$(date)] Bastion initialization started" | tee -a /var/log/bastion-init.log

                # Wait for network
                until ping -c 1 8.8.8.8 &>/dev/null; do
                  echo "Waiting for network..." | tee -a /var/log/bastion-init.log
                  sleep 2
                done

                echo "[$(date)] Network ready" | tee -a /var/log/bastion-init.log

                # Install Tailscale
                echo "[$(date)] Installing Tailscale..." | tee -a /var/log/bastion-init.log
                curl -fsSL https://tailscale.com/install.sh | sh

                # Start Tailscale
                echo "[$(date)] Starting Tailscale..." | tee -a /var/log/bastion-init.log
                tailscale up \
                  --authkey="${TAILSCALE_AUTH_KEY}" \
                  --hostname="${BASTION_HOSTNAME}" \
                  --advertise-tags=tag:bastion \
                  --ssh \
                  --accept-routes \
                  --accept-dns=false

                TAILSCALE_IP=$(tailscale ip -4)
                echo "[$(date)] Tailscale connected: ${TAILSCALE_IP}" | tee -a /var/log/bastion-init.log

                # Create ready marker
                echo "READY" > /tmp/bastion-ready
                echo "[$(date)] Bastion ready" | tee -a /var/log/bastion-init.log
              permissions: '0755'

            - path: /etc/motd
              content: |
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘   OpenStack Tailscale Bastion Host        â•‘
                â•‘   GitHub Actions Packer Build Env        â•‘
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                Logs: /var/log/bastion-init.log
              permissions: '0644'

          timezone: UTC

          users:
            - name: ubuntu
              sudo: ALL=(ALL) NOPASSWD:ALL
              shell: /bin/bash
              groups: sudo
              lock_passwd: true

          ssh_pwauth: false
          disable_root: false

          runcmd:
            - sysctl -p /etc/sysctl.d/99-tailscale.conf
            - /usr/local/bin/bastion-init.sh

          final_message: "Bastion initialization complete after $UPTIME seconds"
          EOFCI

            # Substitute environment variables
            sed -i "s/\${BASTION_HOSTNAME}/$BASTION_HOSTNAME/g" cloud-init.yaml
            sed -i "s/\${TAILSCALE_AUTH_KEY}/$TAILSCALE_AUTH_KEY/g" cloud-init.yaml
          fi

          echo "Cloud-init script created:"
          cat cloud-init.yaml

      - name: Launch bastion instance on OpenStack
        id: launch-bastion
        run: |
          echo "ðŸš€ Launching bastion instance..."

          # Build openstack command with optional SSH key
          CMD="openstack server create"
          CMD="$CMD --flavor '${{ env.OPENSTACK_FLAVOR }}'"
          CMD="$CMD --image '${{ env.OPENSTACK_IMAGE }}'"
          CMD="$CMD --nic net-id=${{ env.OPENSTACK_NETWORK }}"

          # Add SSH key if specified
          if [ -n "${{ env.OPENSTACK_SSH_KEY }}" ]; then
            CMD="$CMD --key-name ${{ env.OPENSTACK_SSH_KEY }}"
            echo "ðŸ“ Using SSH key: ${{ env.OPENSTACK_SSH_KEY }}"
          else
            echo "ðŸ“ No SSH key specified - using Tailscale SSH only"
          fi

          CMD="$CMD --user-data cloud-init.yaml"
          CMD="$CMD --wait"
          CMD="$CMD '${{ env.BASTION_NAME }}'"

          echo "Running: $CMD"
          eval "$CMD"

          echo "âœ… Bastion instance created"

          # Get instance details
          openstack server show "${{ env.BASTION_NAME }}" -f yaml

      - name: Wait for bastion to join Tailscale network
        id: wait-bastion
        timeout-minutes: 10
        run: |
          echo "â³ Waiting for bastion to join Tailscale network..."

          TIMEOUT=${{ env.BASTION_WAIT_TIMEOUT }}
          ELAPSED=0
          INTERVAL=10

          while [ "$ELAPSED" -lt "$TIMEOUT" ]; do
            LINE=$(sudo tailscale status --json 2>/dev/null | jq -r --arg NAME "${{ env.BASTION_NAME }}" '.Peer | to_entries[] | select(.value.HostName==$NAME) | .value.TailscaleIPs[0]' || true)
            if [ -n "$LINE" ] && [ "$LINE" != "null" ]; then
              BASTION_IP="$LINE"
              echo "BASTION_IP=${BASTION_IP}" >> "$GITHUB_ENV"
              echo "âœ… Bastion joined Tailscale at IP: ${BASTION_IP}"

              # Capture status snapshot
              mkdir -p logs
              sudo tailscale status | tee logs/tailscale-after-bastion.txt >/dev/null 2>&1 || true

              echo "Waiting for bastion initialization..."
              for i in {1..24}; do
                if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
                   root@"${BASTION_IP}" "test -f /tmp/bastion-ready" 2>/dev/null; then
                  echo "âœ… Bastion initialization complete (ready marker found)"
                  ssh -o StrictHostKeyChecking=no root@"${BASTION_IP}" \
                    "tail -40 /var/log/bastion-init.log" || true
                  exit 0
                fi
                echo "Waiting for bastion ready marker... (attempt $i/24)"
                sleep 5
              done

              echo "âš ï¸ Bastion reachable but ready marker not found, proceeding anyway..."
              ssh -o StrictHostKeyChecking=no root@"${BASTION_IP}" \
                "sed -n '1,120p' /var/log/bastion-init.log 2>/dev/null || echo 'Log not available'" || true
              exit 0
            fi

            echo "Waiting for bastion... ($ELAPSED/$TIMEOUT seconds)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "âŒ Timeout waiting for bastion to join Tailscale"
          sudo tailscale status || true
          openstack server show "${{ env.BASTION_NAME }}" || true
          openstack console log show "${{ env.BASTION_NAME }}" --lines 100 || true
          exit 1

      # ========================================
      # Step 4: Setup Packer
      # ========================================
      - name: Setup Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Create Packer cloud environment JSON
        env:
          OPENSTACK_AUTH_URL: ${{ secrets.OPENSTACK_AUTH_URL }}
          OPENSTACK_PROJECT_ID: ${{ secrets.OPENSTACK_PROJECT_ID }}
          OPENSTACK_USERNAME: ${{ secrets.OPENSTACK_USERNAME }}
          OPENSTACK_PASSWORD_B64: ${{ secrets.OPENSTACK_PASSWORD_B64 }}
          OPENSTACK_PASSWORD: ${{ secrets.OPENSTACK_PASSWORD }}
          OPENSTACK_NETWORK_ID: ${{ secrets.OPENSTACK_NETWORK_ID }}
        run: |
          # Decode password if base64 encoded version exists, otherwise use plain
          if [ -n "$OPENSTACK_PASSWORD_B64" ]; then
            CLOUD_PASS=$(echo "$OPENSTACK_PASSWORD_B64" | base64 --decode)
          else
            CLOUD_PASS="$OPENSTACK_PASSWORD"
          fi

          # Use network ID from secret, or default if not set
          NETWORK_ID="${OPENSTACK_NETWORK_ID:-b5fcd86e-efac-4997-b8bc-dbe0d35bc229}"

          # Create cloud-env.json for Packer
          cat > "${GITHUB_WORKSPACE}/cloud-env.json" <<EOF
          {
            "cloud_auth_url": "${OPENSTACK_AUTH_URL}",
            "cloud_tenant": "${OPENSTACK_PROJECT_ID}",
            "cloud_user": "${OPENSTACK_USERNAME}",
            "cloud_pass": "${CLOUD_PASS}",
            "cloud_network": "${NETWORK_ID}",
            "ssh_proxy_host": "${{ env.BASTION_IP }}"
          }
          EOF

          echo "âœ… Cloud environment JSON created at ${GITHUB_WORKSPACE}/cloud-env.json"
          echo "   SSH Proxy Host: ${{ env.BASTION_IP }}"
          echo "   Network ID: ${NETWORK_ID}"

      - name: Create Packer cloud environment HCL (optional)
        if: env.CLOUD_ENV_B64 != ''
        env:
          CLOUD_ENV_B64: ${{ secrets.CLOUD_ENV_B64 }}
        run: |
          if [ -n "$CLOUD_ENV_B64" ]; then
            echo "$CLOUD_ENV_B64" | base64 --decode > "${GITHUB_WORKSPACE}/cloud-env.pkrvars.hcl"
            echo "âœ… Cloud environment HCL file created"
          fi

      - name: Create OpenStack clouds.yaml
        if: env.CLOUDS_YAML_B64 != ''
        env:
          CLOUDS_YAML_B64: ${{ secrets.CLOUDS_YAML_B64 }}
        run: |
          if [ -n "$CLOUDS_YAML_B64" ]; then
            mkdir -p "$HOME/.config/openstack"
            echo "$CLOUDS_YAML_B64" | base64 --decode > "$HOME/.config/openstack/clouds.yaml"
            echo "âœ… OpenStack clouds.yaml created"
          else
            echo "âš ï¸ CLOUDS_YAML_B64 secret not set, using environment variables"
          fi

      # ========================================
      # Step 5: Validate and Build with Packer
      # ========================================
      - name: Initialize Packer templates
        working-directory: ${{ needs.prepare.outputs.packer-path }}
        run: |
          echo "Initializing Packer templates..."

          for template in templates/*.pkr.hcl; do
            if [[ "$template" == *"variables"* ]]; then
              continue
            fi

            echo "Initializing $template..."
            packer init "$template" || echo "âš ï¸ Init failed for $template"
          done

      - name: Setup SSH agent for Tailscale
        run: |
          # Start SSH agent and make it available for Packer
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> "$GITHUB_ENV"
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> "$GITHUB_ENV"
          echo "âœ… SSH agent started for Tailscale SSH"

      - name: Validate Packer templates
        working-directory: ${{ needs.prepare.outputs.packer-path }}
        run: |
          set -x

          varfiles=(vars/*.pkrvars.hcl)
          templates=(templates/*.pkr.hcl)

          mkdir -p "${GITHUB_WORKSPACE}/logs"

          for varfile in "${varfiles[@]}"; do
            # Skip cloud-env and example files
            if [[ "$varfile" == *"cloud-env"* ]] || \
               [[ "$varfile" == "vars/*.pkrvars.hcl" ]]; then
              continue
            fi

            # Filter by user input if provided
            if [[ -n "${{ inputs.packer_vars }}" ]] && \
               [[ "$varfile" != *"${{ inputs.packer_vars }}"* ]]; then
              echo "Skipping $varfile (doesn't match filter)"
              continue
            fi

            echo "::group::Validating $varfile"
            for template in "${templates[@]}"; do
              if [[ "$template" == *"variables"* ]]; then
                continue
              fi

              # Filter by user input if provided
              if [[ -n "${{ inputs.packer_template }}" ]] && \
                 [[ "$template" != *"${{ inputs.packer_template }}" ]]; then
                echo "Skipping $template (doesn't match filter)"
                continue
              fi

              export PACKER_LOG=1
              export PACKER_LOG_PATH="${GITHUB_WORKSPACE}/logs/validate-${varfile##*/}-${template##*/}.log"

              # Build packer validate command with cloud-env.json
              PACKER_CMD="packer validate -var-file=${GITHUB_WORKSPACE}/cloud-env.json"
              if [ -f "${GITHUB_WORKSPACE}/cloud-env.pkrvars.hcl" ]; then
                PACKER_CMD="$PACKER_CMD -var-file=${GITHUB_WORKSPACE}/cloud-env.pkrvars.hcl"
              fi
              PACKER_CMD="$PACKER_CMD -var-file=$varfile -var=bastion_host=${{ env.BASTION_IP }} $template"

              if $PACKER_CMD; then
                echo "âœ… $template validated with $varfile"
              else
                echo "âŒ Validation failed for $template with $varfile"
                exit 1
              fi
            done
            echo "::endgroup::"
          done

      - name: Build Packer images
        working-directory: ${{ needs.prepare.outputs.packer-path }}
        env:
          PACKER_LOG: ${{ inputs.debug_mode && '1' || '0' }}
        run: |
          set -x

          varfiles=(vars/*.pkrvars.hcl)
          templates=(templates/*.pkr.hcl)

          mkdir -p "${GITHUB_WORKSPACE}/build-logs"

          build_count=0
          max_builds=5  # Limit concurrent builds

          for varfile in "${varfiles[@]}"; do
            # Skip cloud-env and example files
            if [[ "$varfile" == *"cloud-env"* ]] || \
               [[ "$varfile" == "vars/*.pkrvars.hcl" ]]; then
              continue
            fi

            # Filter by user input if provided
            if [[ -n "${{ inputs.packer_vars }}" ]] && \
               [[ "$varfile" != *"${{ inputs.packer_vars }}"* ]]; then
              echo "Skipping $varfile (doesn't match filter)"
              continue
            fi

            if [ $build_count -ge $max_builds ]; then
              echo "âš ï¸ Reached maximum builds limit ($max_builds)"
              break
            fi

            echo "::group::Building with $varfile"
            for template in "${templates[@]}"; do
              if [[ "$template" == *"variables"* ]]; then
                continue
              fi

              # Filter by user input if provided
              if [[ -n "${{ inputs.packer_template }}" ]] && \
                 [[ "$template" != *"${{ inputs.packer_template }}" ]]; then
                echo "Skipping $template (doesn't match filter)"
                continue
              fi

              export PACKER_LOG_PATH="${GITHUB_WORKSPACE}/build-logs/build-${varfile##*/}-${template##*/}.log"

              echo "ðŸ”¨ Building $template with $varfile via bastion ${{ env.BASTION_IP }}..."

              # Build packer build command with cloud-env.json
              PACKER_CMD="packer build -var-file=${GITHUB_WORKSPACE}/cloud-env.json"
              if [ -f "${GITHUB_WORKSPACE}/cloud-env.pkrvars.hcl" ]; then
                PACKER_CMD="$PACKER_CMD -var-file=${GITHUB_WORKSPACE}/cloud-env.pkrvars.hcl"
              fi
              PACKER_CMD="$PACKER_CMD -var-file=$varfile -var=bastion_host=${{ env.BASTION_IP }} -var=bastion_user=root $template"

              if $PACKER_CMD; then
                echo "âœ… Successfully built $template with $varfile"
                build_count=$((build_count + 1))
              else
                echo "âŒ Build failed for $template with $varfile"
                echo "::warning::Build failed for $template with $varfile"
                # Continue with other builds
              fi

              # Only build one template per varfile to limit resource usage
              break
            done
            echo "::endgroup::"
          done

          echo "ðŸ“Š Completed $build_count builds"

      # ========================================
      # Step 6: Upload Artifacts and Logs
      # ========================================
      - name: Upload Packer logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: packer-logs-${{ github.run_id }}
          path: |
            logs/
            build-logs/
          retention-days: 30

      - name: Capture bastion IP & status (runner)
        if: env.BASTION_IP == ''
        run: |
          # Fallback: record current runner tailscale IPs
          mkdir -p logs
          sudo tailscale ip -4 | head -1 | sed 's/^/Runner TS IPv4: /'
          sudo tailscale ip -6 | head -1 | sed 's/^/Runner TS IPv6: /'
          sudo tailscale status | tee logs/tailscale-pre-upload.txt >/dev/null 2>&1 || true

      - name: Upload bastion logs
        if: always() && env.BASTION_IP != ''
        continue-on-error: true
        run: |
          mkdir -p bastion-logs
          SSH_OPTS='-o StrictHostKeyChecking=no -o ConnectTimeout=10'
          ssh "${SSH_OPTS}" "root@${{ env.BASTION_IP }}" "cat /var/log/cloud-init-output.log" > bastion-logs/cloud-init-output.log 2>&1 || true
          ssh "${SSH_OPTS}" "root@${{ env.BASTION_IP }}" "cloud-init status --long" > bastion-logs/cloud-init-status.log 2>&1 || true
          ssh "${SSH_OPTS}" "root@${{ env.BASTION_IP }}" "tail -120 /var/log/bastion-init.log" > bastion-logs/bastion-init-tail.log 2>&1 || true
          sudo tailscale status | tee bastion-logs/runner-tailscale-status.txt >/dev/null 2>&1 || true

      - name: Upload bastion diagnostics
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: bastion-logs-${{ github.run_id }}
          path: bastion-logs/
          retention-days: 7

      # ========================================
      # Step 7: Cleanup (Always Runs)
      # ========================================
      - name: Cleanup bastion instance
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up bastion instance..."

          # Remove from Tailscale (optional, ephemeral keys auto-cleanup)
          if [ -n "${{ env.BASTION_IP }}" ]; then
            sudo tailscale logout || true
          fi

          # Delete OpenStack instance
          if openstack server show "${{ env.BASTION_NAME }}" &>/dev/null; then
            echo "Deleting bastion instance..."
            openstack server delete --wait "${{ env.BASTION_NAME }}" || {
              echo "âš ï¸ Failed to delete bastion cleanly, force deleting..."
              openstack server delete "${{ env.BASTION_NAME }}" || true
            }
            echo "âœ… Bastion instance deleted"
          else
            echo "âš ï¸ Bastion instance not found, may have been deleted already"
          fi

      - name: Verify cleanup
        if: always()
        run: |
          echo "Verifying cleanup..."

          if openstack server show "${{ env.BASTION_NAME }}" &>/dev/null; then
            echo "âš ï¸ Warning: Bastion instance still exists!"
            openstack server show "${{ env.BASTION_NAME }}"
          else
            echo "âœ… Bastion instance cleanup verified"
          fi

          echo "Final Tailscale status:"
          sudo tailscale status || true

  # ========================================
  # Summary Job
  # ========================================
  summary:
    if: always()
    needs: [prepare, packer-build-openstack]
    runs-on: ubuntu-latest
    steps:
      - name: Build summary
        run: |
          {
            echo "## Packer Build Summary"
            echo ""
            echo "- **Workflow:** ${{ github.workflow }}"
            echo "- **Run ID:** ${{ github.run_id }}"
            echo "- **Trigger:** ${{ github.event_name }}"
            echo "- **Branch:** ${{ github.ref_name }}"
            echo "- **Bastion:** ${{ env.BASTION_NAME }}"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ needs.packer-build-openstack.result }}" == "success" ]; then
            echo "âœ… **Build Status:** Success" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ **Build Status:** Failed" >> "$GITHUB_STEP_SUMMARY"
          fi
